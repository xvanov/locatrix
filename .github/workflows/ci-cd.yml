name: CI/CD Pipeline

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  pull_request:
    branches:
      - main

env:
  AWS_REGION: us-east-1
  PYTHON_VERSION: '3.11'

permissions:
  contents: write
  id-token: write
  pull-requests: write

jobs:
  build:
    name: Build SAM Application
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install SAM CLI
        uses: aws-actions/setup-sam@v2
        with:
          use-installer: true

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r src/requirements.txt

      - name: SAM Build
        id: build
        run: |
          echo "Building SAM application..."
          sam build --use-container || sam build
          echo "Build completed"
          echo "Checking build output..."
          ls -la .aws-sam/ || echo "Warning: .aws-sam directory not found immediately after build"
        continue-on-error: false

      - name: Verify build output
        id: verify-build
        run: |
          if [ ! -d ".aws-sam" ]; then
            echo "Error: .aws-sam directory was not created"
            exit 1
          fi
          
          # Check for actual files, not just directories
          file_count=$(find .aws-sam -type f | wc -l)
          if [ "$file_count" -eq 0 ]; then
            echo "Error: .aws-sam directory contains no files"
            echo "Current directory contents:"
            ls -la
            echo "Checking for .aws-sam:"
            ls -la .aws-sam/ || echo ".aws-sam directory exists but is empty"
            echo "Directory structure:"
            find .aws-sam -type d
            exit 1
          fi
          
          echo "✅ Build output verified - found $file_count files"
          echo "Sample files:"
          find .aws-sam -type f | head -10
          echo "Full directory tree:"
          tree .aws-sam || find .aws-sam
          echo "artifact-ready=true" >> $GITHUB_OUTPUT

      - name: Upload build artifacts
        if: steps.verify-build.outcome == 'success'
        run: |
          echo "Preparing to upload artifacts..."
          echo "Checking .aws-sam exists:"
          ls -la .aws-sam || exit 1
          echo "File count:"
          find .aws-sam -type f | wc -l
          echo "Creating archive..."
          tar -czf build-artifacts.tar.gz .aws-sam/ || exit 1
          echo "Archive created, size:"
          ls -lh build-artifacts.tar.gz

      - name: Upload build artifacts archive
        if: steps.verify-build.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: build-artifacts.tar.gz
          retention-days: 7
          if-no-files-found: error

  lint:
    name: Lint and Type Check
    runs-on: ubuntu-latest
    needs: build
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r src/requirements.txt
          pip install flake8 mypy

      - name: Run flake8
        run: |
          flake8 src/ --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 src/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
        continue-on-error: false

      - name: Run mypy
        run: |
          mypy src/ --ignore-missing-imports || true
        continue-on-error: false

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: build
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r src/requirements.txt
          pip install pytest pytest-cov

      - name: Run unit tests
        run: |
          pytest src/tests/unit/ -v --tb=short

      - name: Run integration tests
        run: |
          pytest src/tests/integration/ -v --tb=short

      - name: Run E2E tests
        run: |
          pytest src/tests/e2e/ -v --tb=short || true

  deploy-dev:
    name: Deploy to Dev Environment
    runs-on: ubuntu-latest
    needs: [build, lint, test]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: dev
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install SAM CLI
        uses: aws-actions/setup-sam@v2
        with:
          use-installer: true

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r src/requirements.txt

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Clean up and prepare for deployment (dev)
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          chmod +x scripts/test-deploy-local.sh
          chmod +x scripts/delete-buckets.sh
          # Run cleanup steps only (non-interactive, cleanup-only mode)
          # This handles: bucket cleanup, conflicting stack cleanup, failed stack cleanup
          ./scripts/test-deploy-local.sh dev --non-interactive --cleanup-only

      - name: Download build artifacts
        id: download-artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: .
        continue-on-error: true

      - name: Extract build artifacts
        if: steps.download-artifacts.outcome == 'success'
        id: extract-artifacts
        run: |
          if [ -f "build-artifacts.tar.gz" ]; then
            echo "Extracting build artifacts..."
            tar -xzf build-artifacts.tar.gz
            echo "✅ Artifacts extracted"
            ls -la .aws-sam/ || echo "Warning: .aws-sam not found after extraction"
          else
            echo "Archive file not found"
            exit 1
          fi
        continue-on-error: true

      - name: Verify artifacts downloaded
        if: steps.download-artifacts.outcome == 'success' && steps.extract-artifacts.outcome == 'success'
        id: verify-artifacts
        run: |
          if [ ! -d ".aws-sam" ] || [ -z "$(ls -A .aws-sam 2>/dev/null)" ]; then
            echo "Artifacts directory is empty or missing"
            exit 1
          fi
          echo "✅ Build artifacts verified"
        continue-on-error: true

      - name: SAM Build (fallback if artifacts not available)
        if: steps.download-artifacts.outcome == 'failure' || steps.extract-artifacts.outcome == 'failure' || steps.verify-artifacts.outcome == 'failure'
        run: |
          echo "⚠️ Artifacts not available, rebuilding..."
          sam build --use-container || sam build
          echo "✅ Rebuild completed"

      - name: SAM Deploy to Dev
        id: deploy
        run: |
          sam deploy \
            --config-file samconfig.dev.toml \
            --stack-name location-detection-dev \
            --capabilities CAPABILITY_IAM \
            --resolve-s3 \
            --no-confirm-changeset \
            --no-fail-on-empty-changeset \
            --region ${{ env.AWS_REGION }}
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          SAM_CLI_TELEMETRY: 0

      - name: Get API URL from stack outputs
        if: steps.deploy.outcome == 'success'
        id: stack-outputs
        run: |
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name location-detection-dev \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiUrl`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }} || echo "")
          if [ -z "$API_URL" ]; then
            echo "Warning: Could not retrieve API URL from stack outputs"
            echo "api-url=" >> $GITHUB_OUTPUT
          else
            echo "api-url=$API_URL" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Output deployment status
        if: steps.deploy.outcome == 'success'
        run: |
          echo "✅ Deployment to dev environment completed successfully"
          if [ -n "${{ steps.stack-outputs.outputs.api-url }}" ]; then
            echo "API URL: ${{ steps.stack-outputs.outputs.api-url }}"
          else
            echo "API URL: Not available (check CloudFormation stack outputs)"
          fi

  deploy-prod:
    name: Deploy to Prod Environment
    runs-on: ubuntu-latest
    needs: [build, lint, test]
    if: startsWith(github.ref, 'refs/tags/v')
    environment:
      name: prod
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install SAM CLI
        uses: aws-actions/setup-sam@v2
        with:
          use-installer: true

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r src/requirements.txt

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check and clean up failed stack
        run: |
          STACK_NAME="location-detection-prod"
          ENV="prod"
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name $STACK_NAME \
            --query 'Stacks[0].StackStatus' \
            --output text \
            --region ${{ env.AWS_REGION }} 2>/dev/null || echo "NOT_FOUND")
          
          if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "DELETE_FAILED" ]; then
            echo "⚠️ Found failed stack in status: $STACK_STATUS"
            echo "Deleting failed stack..."
            aws cloudformation delete-stack \
              --stack-name $STACK_NAME \
              --region ${{ env.AWS_REGION }}
            
            echo "Waiting for stack deletion to complete..."
            aws cloudformation wait stack-delete-complete \
              --stack-name $STACK_NAME \
              --region ${{ env.AWS_REGION }} || echo "Stack deletion completed or timed out"
            
            echo "✅ Failed stack cleaned up"
            # Wait a bit more to ensure all resources are fully deleted
            echo "Waiting for resources to fully propagate..."
            sleep 10
          elif [ "$STACK_STATUS" = "NOT_FOUND" ]; then
            echo "✅ No existing stack found"
          else
            echo "ℹ️ Stack exists with status: $STACK_STATUS (will update)"
          fi
          
          # Clean up orphaned resources that might exist outside the stack
          # Only clean up if stack doesn't exist (to avoid conflicts with CloudFormation deletions)
          if [ "$STACK_STATUS" = "NOT_FOUND" ]; then
            echo "Checking for orphaned resources..."
            
            # Check and delete orphaned S3 buckets (with proper versioning/MFA handling)
            BLUEPRINTS_BUCKET="location-detection-${ENV}-blueprints"
            CACHE_BUCKET="location-detection-${ENV}-cache"
            
            for BUCKET in "$BLUEPRINTS_BUCKET" "$CACHE_BUCKET"; do
              if aws s3api head-bucket --bucket "$BUCKET" --region ${{ env.AWS_REGION }} 2>/dev/null; then
                echo "⚠️ Found orphaned S3 bucket: $BUCKET"
                
                # Delete all objects and versions
                echo "Deleting bucket contents..."
                aws s3 rm s3://$BUCKET --recursive --region ${{ env.AWS_REGION }} || true
                
                # Delete all object versions (for versioned buckets)
                VERSIONS=$(aws s3api list-object-versions --bucket "$BUCKET" --query '{Objects: Versions[].{Key:Key,VersionId:VersionId}}' --output json --region ${{ env.AWS_REGION }} 2>/dev/null)
                if [ "$VERSIONS" != "null" ] && [ "$VERSIONS" != "{}" ] && [ -n "$VERSIONS" ]; then
                  echo "Deleting object versions..."
                  aws s3api delete-objects --bucket "$BUCKET" --delete "$VERSIONS" --region ${{ env.AWS_REGION }} 2>/dev/null || true
                fi
                
                # Delete delete markers
                MARKERS=$(aws s3api list-object-versions --bucket "$BUCKET" --query '{Objects: DeleteMarkers[].{Key:Key,VersionId:VersionId}}' --output json --region ${{ env.AWS_REGION }} 2>/dev/null)
                if [ "$MARKERS" != "null" ] && [ "$MARKERS" != "{}" ] && [ -n "$MARKERS" ]; then
                  echo "Deleting delete markers..."
                  aws s3api delete-objects --bucket "$BUCKET" --delete "$MARKERS" --region ${{ env.AWS_REGION }} 2>/dev/null || true
                fi
                
                # Disable versioning if enabled
                echo "Disabling versioning..."
                aws s3api put-bucket-versioning \
                  --bucket "$BUCKET" \
                  --versioning-configuration Status=Suspended \
                  --region ${{ env.AWS_REGION }} 2>/dev/null || true
                
                # Delete bucket
                echo "Deleting bucket..."
                aws s3api delete-bucket --bucket "$BUCKET" --region ${{ env.AWS_REGION }} && echo "✅ Deleted bucket: $BUCKET" || echo "⚠️ Could not delete bucket: $BUCKET (may need manual cleanup)"
              fi
            done
            
            # Check and delete orphaned DynamoDB tables
            JOBS_TABLE="${ENV}-jobs"
            PREVIEW_TABLE="${ENV}-preview-cache"
            
            for TABLE in "$JOBS_TABLE" "$PREVIEW_TABLE"; do
              TABLE_STATUS=$(aws dynamodb describe-table --table-name "$TABLE" --region ${{ env.AWS_REGION }} --query 'Table.TableStatus' --output text 2>/dev/null || echo "NOT_FOUND")
              if [ "$TABLE_STATUS" != "NOT_FOUND" ]; then
                echo "⚠️ Found orphaned DynamoDB table: $TABLE (status: $TABLE_STATUS)"
                if [ "$TABLE_STATUS" = "ACTIVE" ] || [ "$TABLE_STATUS" = "DELETING" ]; then
                  echo "Deleting table..."
                  aws dynamodb delete-table --table-name "$TABLE" --region ${{ env.AWS_REGION }} && echo "✅ Deleted table: $TABLE" || echo "⚠️ Could not delete table: $TABLE"
                fi
              fi
            done
            
            echo "✅ Orphaned resource cleanup completed"
          else
            echo "Stack exists - skipping orphaned resource cleanup (CloudFormation will manage resources)"
          fi
          
          # Wait for any in-progress deletions to complete
          echo "Waiting 30 seconds for AWS to fully propagate any deletions..."
          sleep 30
          
          # Verify buckets are actually deleted (with retries)
          echo "Verifying buckets are fully deleted..."
          MAX_RETRIES=10
          RETRY_COUNT=0
          
          BLUEPRINTS_BUCKET="location-detection-${ENV}-blueprints"
          CACHE_BUCKET="location-detection-${ENV}-cache"
          
          for BUCKET in "$BLUEPRINTS_BUCKET" "$CACHE_BUCKET"; do
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              # Check if bucket exists
              if aws s3api head-bucket --bucket "$BUCKET" --region ${{ env.AWS_REGION }} 2>/dev/null; then
                echo "⚠️ Bucket $BUCKET still exists (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES), waiting 10 seconds..."
                sleep 10
                RETRY_COUNT=$((RETRY_COUNT + 1))
              else
                echo "✅ Bucket $BUCKET confirmed deleted"
                break
              fi
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "⚠️ Bucket $BUCKET still exists after $MAX_RETRIES attempts. It may be in a deleting state."
              echo "This is usually fine - CloudFormation will handle it."
            fi
          done
          
          echo "Proceeding with deployment..."

      - name: Download build artifacts
        id: download-artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: .
        continue-on-error: true

      - name: Extract build artifacts
        if: steps.download-artifacts.outcome == 'success'
        id: extract-artifacts
        run: |
          if [ -f "build-artifacts.tar.gz" ]; then
            echo "Extracting build artifacts..."
            tar -xzf build-artifacts.tar.gz
            echo "✅ Artifacts extracted"
            ls -la .aws-sam/ || echo "Warning: .aws-sam not found after extraction"
          else
            echo "Archive file not found"
            exit 1
          fi
        continue-on-error: true

      - name: Verify artifacts downloaded
        if: steps.download-artifacts.outcome == 'success' && steps.extract-artifacts.outcome == 'success'
        id: verify-artifacts
        run: |
          if [ ! -d ".aws-sam" ] || [ -z "$(ls -A .aws-sam 2>/dev/null)" ]; then
            echo "Artifacts directory is empty or missing"
            exit 1
          fi
          echo "✅ Build artifacts verified"
        continue-on-error: true

      - name: SAM Build (fallback if artifacts not available)
        if: steps.download-artifacts.outcome == 'failure' || steps.extract-artifacts.outcome == 'failure' || steps.verify-artifacts.outcome == 'failure'
        run: |
          echo "⚠️ Artifacts not available, rebuilding..."
          sam build --use-container || sam build
          echo "✅ Rebuild completed"

      - name: SAM Deploy to Prod
        id: deploy
        run: |
          sam deploy \
            --config-file samconfig.prod.toml \
            --stack-name location-detection-prod \
            --capabilities CAPABILITY_IAM \
            --resolve-s3 \
            --no-confirm-changeset \
            --no-fail-on-empty-changeset \
            --region ${{ env.AWS_REGION }}
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          SAM_CLI_TELEMETRY: 0

      - name: Extract tag name
        id: tag
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "tag-name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Extracted tag: $TAG_NAME"

      - name: Get API URL from stack outputs
        if: steps.deploy.outcome == 'success'
        id: stack-outputs
        run: |
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name location-detection-prod \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiUrl`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }} || echo "")
          if [ -z "$API_URL" ]; then
            echo "Warning: Could not retrieve API URL from stack outputs"
            echo "api-url=" >> $GITHUB_OUTPUT
          else
            echo "api-url=$API_URL" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Create GitHub Release
        if: steps.deploy.outcome == 'success'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.tag.outputs.tag-name }}
          name: Release ${{ steps.tag.outputs.tag-name }}
          body: |
            Production deployment completed successfully.
            
            **API URL:** ${{ steps.stack-outputs.outputs.api-url }}
            
            **Deployed at:** ${{ github.event.head_commit.timestamp || github.event.repository.updated_at }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

